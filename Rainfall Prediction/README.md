# Simple Rainfall Prediction (Nairobi) ğŸŒ§ï¸

**Short project summary**

A compact exploratory and modelling notebook that uses ERA5 total precipitation (TP) to build a simple daily rainfall prediction model for Nairobi, Kenya. The workflow uses the Climate Data Store (`cdsapi`) to retrieve ERA5 TP for 2024, processes it with `xarray` and `pandas`, engineers a few time-series features, and then fits a simple `LinearRegression` model from `scikit-learn`.

---

## ğŸ“ Project structure

- `simple_rainfall_predict_model.ipynb` â€” the main notebook with the complete workflow and plots
- `era5_kenya_tp_2024.nc` â€” ERA5 total precipitation for Kenya (2024) [generated by the notebook using `cdsapi`]

---

## ğŸ”¬ Data

- Source: ERA5 (ECMWF) â€” total precipitation (TP)
- Time period: 2024 (hourly/3-hourly ERA5 timestamps)
- Region: Kenya (downloaded using a bounding box in the notebook)

Key preprocessing steps:
- Convert TP from meters to millimetres by multiplying by 1000.
- Aggregate 3-hourly timestamps to daily totals (the dataset had 8 timestamps per day for 366 days in 2024).

Example code:

```python
import cdsapi
import xarray as xr

# after download
ds = xr.load_dataset("era5_kenya_tp_2024.nc")
rainfall_mm = ds["tp"] * 1000
# group to daily totals (note: dataset uses a `valid_time` dimension in the notebook)
daily_rainfall = rainfall_mm.resample(valid_time="1D").sum()
```

---

## ğŸ“ Extracting a location (Nairobi)

You can select the nearest grid point to Nairobi with its coordinates and convert to a `pandas` DataFrame for analysis:

```python
nairobi_rain = daily_rainfall.sel(
    latitude=-1.29,
    longitude=36.82,
    method="nearest"
)
df_nairobi = nairobi_rain.to_dataframe(name="nairobi_rain_2024_mm")
```

A quick plot of `df_nairobi["nairobi_rain_2024_mm"].plot()` shows a notable spike around May that corresponds to recorded floods in that period.

---

## âš™ï¸ Feature engineering

The notebook uses three simple, interpretable features:

- `lag_yesterday` â€” previous day rainfall (persistence)
- `3_days_cumulative` â€” rolling 3-day cumulative rainfall (moisture persistence)
- `wet_day` â€” binary indicator (1 if daily rainfall > 1 mm else 0)

```python
df_nairobi["lag_yesterday"] = df_nairobi["nairobi_rain_2024_mm"].shift(1)
df_nairobi["3_days_cumulative"] = df_nairobi["nairobi_rain_2024_mm"].rolling(3).sum()
df_nairobi["wet_day"] = (df_nairobi["nairobi_rain_2024_mm"] > 1).astype("int64")
df_nairobi = df_nairobi.dropna()
```

---

## ğŸ§  Model, training and evaluation

- Inputs (X): `[[lag_yesterday, 3_days_cumulative, wet_day]]`
- Target (y): `nairobi_rain_2024_mm`
- Time-series split: Manual 70/30 split using `.iloc` to avoid shuffling temporal order.

```python
split_index = int(len(x) * 0.7)
x_train = x.iloc[:split_index]; x_test = x.iloc[split_index:]
y_train = y.iloc[:split_index]; y_test = y.iloc[split_index:]
```

Model: `sklearn.linear_model.LinearRegression`

Metric: Mean Absolute Error (MAE)

Observed MAE: **0.26994199292596954 mm**

You can also plot observed vs predicted to inspect performance:

```python
from sklearn.metrics import mean_absolute_error
mae = mean_absolute_error(y_test, y_predicted)
print("MAE (mm):", mae)

# plotting
plt.figure(figsize=(15,8))
plt.plot(y_test.values, label="Observed")
plt.plot(y_predicted, label="Predicted")
plt.legend()
plt.title("Observed vs Predicted Daily Rainfall in Nairobi 2024")
plt.ylabel("Rainfall (mm)")
plt.xlabel("Time (days)")
plt.show()
```

---

## ğŸ“ˆ Main observations

1. **Dry spells**: Model correctly identifies long dry periods (Observed â‰ˆ 0 mm, Predicted â‰ˆ 0 mm). This is important for operational use.
2. **Lightâ€“moderate events (1â€“3 mm)**: Timing and magnitude are often well-captured; persistence features perform well.
3. **Heavy/extreme events**: Model detects events but tends to **underestimate intensity** (e.g., observed ~6.8 mm vs predicted ~4 mm for the biggest spike).

Interpretation: This is expected â€” linear regression with rainfall-only predictors captures tendencies and persistence but lacks dynamical atmospheric predictors needed to resolve extremes.

---

## âš ï¸ Limitations & recommended next steps

- Add dynamic/predictive features (e.g., humidity, wind, CAPE, large scale indices) to capture extreme events.
- Try non-linear / tree-based models (Random Forest, Gradient Boosting, or neural networks).
- Use time-series cross-validation (e.g., expanding window) for more robust evaluation.
- Experiment with probabilistic forecasts and different thresholds for binary rainfall occurrence.

---

## ğŸ›  Reproducibility / Requirements

Minimum packages used in the notebook:

- cdsapi
- xarray
- pandas
- numpy
- scikit-learn
- matplotlib

You can install them with:

```bash
pip install -r requirements.txt
# or
pip install cdsapi xarray pandas numpy scikit-learn matplotlib
```

---

## ğŸ“š References

- ERA5 data via Copernicus Climate Data Store (CDS)
- xarray documentation for netCDF processing

---

## ğŸ“ License

MIT License â€” feel free to reuse and extend this mini-project for research or teaching purposes.

---

